use std::{
    fs::{File, OpenOptions},
    io::{BufRead, BufReader, Error as ioError, Write},
    path::Path,
};

use pest::{
    iterators::{Pair, Pairs},
    Parser,
};
use pest_derive::Parser;
use thiserror::Error;

/// Parser structure which is used to parse text with the grammar defined in `src/grammar.pest`.
/// It is automatically generated by `pest_derive` based on the specified grammar.
#[derive(Parser)]
#[grammar = "./grammar.pest"]
pub struct Grammar;

/// Enum representing possible errors encountered during parsing or file operations.
#[derive(Error, Debug)]
pub enum ErrorParse {
    /// Error when there is a parsing issue with the markdown input.
    #[error("An error occurrred while parsing: {0}")]
    ParsingError(String),

    /// Error when there is a file operation issue: file read/write.
    #[error("A file error occurrred: {0}")]
    FileError(#[from] ioError),
}

/// Converts provided `text` in markdown format to HTML, returning a vector of HTML lines.
/// 
/// # Arguments
/// * `text` - A string slice containing the markdown content. All lines in the text are separated by new line breaks.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing either a vector of HTML lines or a `ErrorParse` if the parsing fails.
pub fn str_to_html(text: &str) -> Result<Vec<String>, ErrorParse> {
    let parsed_pairs =
        parse_markdown(text).map_err(|e| ErrorParse::ParsingError(format!("{:?}", e)))?;

    let markdown_content = parsed_pairs
        .into_iter()
        .next()
        .ok_or_else(|| ErrorParse::ParsingError(String::from("Expected markdown got nothing")))?;

    let html_lines: Result<Vec<String>, ErrorParse> = markdown_content
        .into_inner()
        .map(|pair| to_html(pair))
        .collect();

    html_lines
}

/// Converts a `pest::iterators::Pair` representing a single rule into an HTML string.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the parsed rule to convert.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing either the corresponding HTML string or an `ErrorParse` if the rule is unknown or an error occurs.
pub fn to_html(pair: Pair<Rule>) -> Result<String, ErrorParse> {
    match pair.as_rule() {
        Rule::empty_line => Ok(String::from("<br/>")),
        Rule::heading1 => Ok(format!("<h1>{}</h1>", parse_heading(pair)?)),
        Rule::heading2 => Ok(format!("<h2>{}</h2>", parse_heading(pair)?)),
        Rule::heading3 => Ok(format!("<h3>{}</h3>", parse_heading(pair)?)),
        Rule::code_block => match parse_code_block(pair) {
            Ok((lang, content)) => Ok(format!(
                "<pre><code class=\"language-{}\">{}</code></pre>",
                lang, content
            )),
            Err(err) => Err(err),
        },
        Rule::quote => Ok(format!("<blockquote>{}</blockquote>", parse_quote(pair)?)),
        Rule::horizontal_rule => Ok(String::from("<hr>")),
        Rule::paragraph => Ok(format!("<p>{}</p>", parse_paragraph(pair)?)),
        Rule::inline_link => match parse_inline_link(pair) {
            Ok((link_text, url)) => Ok(format!("<a href=\"{}\">{}</a>", url, link_text)),
            Err(err) => Err(err),
        },
        Rule::inline_image => match parse_inline_image(pair) {
            Ok((alt_text, url)) => Ok(format!("<img src=\"{}\" alt=\"{}\">", url, alt_text)),
            Err(err) => Err(err),
        },
        Rule::bold => Ok(format!("<strong>{}</strong>", parse_styled_text(pair)?)),
        Rule::italic => Ok(format!("<em>{}</em>", parse_styled_text(pair)?)),
        Rule::strikethrough => Ok(format!("<del>{}</del>", parse_styled_text(pair)?)),
        Rule::underline => Ok(format!("<u>{}</u>", parse_styled_text(pair)?)),
        Rule::escaped => Ok(parse_escaped_char(pair)?),
        Rule::content => Ok(String::from(html_escape::encode_text(pair.as_str()))),
        Rule::plain_text => Ok(String::from(html_escape::encode_text(pair.as_str()))),
        Rule::EOI => Ok(String::new()),
        _ => Err(ErrorParse::ParsingError(format!(
            "Unknown rule: {:#?}",
            pair.as_rule()
        ))),
    }
}

/// Parses an escaped character from the markdown syntax, such as escaped special characters.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the escaped character rule.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing the encoded HTML representation of the escaped character.
fn parse_escaped_char(pair: Pair<Rule>) -> Result<String, ErrorParse> {
    let mut inner = pair.into_inner();
    let char_sym = inner
        .next()
        .ok_or_else(|| {
            ErrorParse::ParsingError(String::from("Expected char rule inside an escaped"))
        })?
        .as_str();

    let encoded_char = String::from(html_escape::encode_text(char_sym));
    Ok(encoded_char)
}

/// Parses styled text such as bold, italic, strikethrough, or underline in the markdown input.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the styled text rule.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing the HTML string of the styled content.
fn parse_styled_text(pair: Pair<Rule>) -> Result<String, ErrorParse> {
    let inner = pair.into_inner();
    let mut html_content = String::new();

    for rule in inner {
        let content = to_html(rule)?;
        html_content.push_str(content.as_str());
    }

    Ok(html_content)
}

/// Parses an inline image (e.g., `![alt_text](url)`) in the markdown input.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the inline image rule.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing a tuple of the encoded alt text and URL of the image.
fn parse_inline_image(pair: Pair<Rule>) -> Result<(String, String), ErrorParse> {
    let mut inner = pair.into_inner();
    let alt_text = inner
        .next()
        .ok_or_else(|| {
            ErrorParse::ParsingError(String::from(
                "Expected link_text rule inside an inline_link",
            ))
        })?
        .as_str();
    let url = inner
        .next()
        .ok_or_else(|| ErrorParse::ParsingError(String::from("Expected url inside a inline_link")))?
        .as_str();

    let alt_text_encoded = String::from(html_escape::encode_text(alt_text));
    let url_string = String::from(url);

    Ok((alt_text_encoded, url_string))
}

/// Parses an inline link (e.g., `[link_text](url)`) in the markdown input.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the inline link rule.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing a tuple of the encoded link text and URL.
fn parse_inline_link(pair: Pair<Rule>) -> Result<(String, String), ErrorParse> {
    let mut inner = pair.into_inner();
    let link_text = inner
        .next()
        .ok_or_else(|| {
            ErrorParse::ParsingError(String::from(
                "Expected link_text rule inside an inline_link",
            ))
        })?
        .as_str();
    let link_url = inner
        .next()
        .ok_or_else(|| ErrorParse::ParsingError(String::from("Expected url inside a inline_link")))?
        .as_str();

    let link_text_encoded = String::from(html_escape::encode_text(link_text));
    let url_string = String::from(link_url);

    Ok((link_text_encoded, url_string))
}

/// Parses a paragraph from the markdown input. 
/// A paragraph is a collection of paragraph lines. Line containt either a plain_text, escaped character or styled_text.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the paragraph rule.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing the HTML representation of the entire paragraph.
fn parse_paragraph(pair: Pair<Rule>) -> Result<String, ErrorParse> {
    let inner_lines = pair.into_inner();
    let total_lines = inner_lines.len();
    let mut html_content = String::new();

    for (i, line) in inner_lines.enumerate() {
        match line.as_rule() {
            Rule::paragraph_line => {
                let line_content = line
                    .clone()
                    .into_inner()
                    .map(|text| to_html(text))
                    .collect::<Result<String, ErrorParse>>()?;
                html_content.push_str(line_content.as_str());

                if i < total_lines - 1 {
                    html_content.push_str("<br>");
                }
            }
            _ => {
                return Err(ErrorParse::ParsingError(format!(
                    "Unexpected rule inside a paragraph: {:#?}",
                    line.as_rule()
                )));
            }
        }
    }

    Ok(html_content)
}

/// Parses a blockquote (e.g., `> quote text`) from the markdown input.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the blockquote rule.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing the HTML representation of the blockquote.
fn parse_quote(pair: Pair<Rule>) -> Result<String, ErrorParse> {
    let mut inner = pair.into_inner();
    let paragraph = inner.next().ok_or_else(|| {
        ErrorParse::ParsingError(String::from("Expected paragraph rule inside a quote"))
    })?;
    to_html(paragraph)
}

/// Parses a code block from the markdown input.
/// Code block always has a content and may have a language of the code.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the code block rule.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing a tuple with the language and the HTML-encoded code content.
fn parse_code_block(pair: Pair<Rule>) -> Result<(String, String), ErrorParse> {
    let mut inner = pair.into_inner();
    let code_lang = inner
        .next()
        .ok_or_else(|| {
            ErrorParse::ParsingError(String::from("Expected code_lang rule iside an code block"))
        })?
        .as_str();
    let code_content = inner
        .next()
        .ok_or_else(|| {
            ErrorParse::ParsingError(String::from("Expected code content inside a code block"))
        })?
        .as_str();

    let code_encoded = String::from(html_escape::encode_text(code_lang));
    let content_encoded = String::from(html_escape::encode_text(code_content));

    Ok((code_encoded, content_encoded))
}


/// Parses a heading (e.g., `# Heading 1`) from the markdown input.
/// 
/// # Arguments
/// * `pair` - A `pest::iterators::Pair` representing the heading rule.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing the HTML-encoded heading text.
fn parse_heading(pair: Pair<Rule>) -> Result<String, ErrorParse> {
    let mut inner = pair.into_inner();
    let sngl_line_text = inner.next().ok_or_else(|| {
        ErrorParse::ParsingError(String::from(
            "Expected single_line_text rule inside a header",
        ))
    })?;

    let text: &str = sngl_line_text.as_str();

    Ok(String::from(html_escape::encode_text(text)))
}

/// Parses the given `input` markdown string and returns a `pest::iterators::Pairs` of rules.
/// 
/// # Arguments
/// * `input` - A string containing the markdown content.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing either the parsed `pest::iterators::Pairs` or an `ErrorParse` if the parsing fails.
pub fn parse_markdown(input: &str) -> Result<Pairs<Rule>, ErrorParse> {
    return Grammar::parse(Rule::markdown, input)
        .map_err(|err| ErrorParse::ParsingError(err.to_string()));
}

/// Parses the `input` string according to a specific rule and returns the resulting pairs.
/// 
/// # Arguments
/// * `rule` - The rule to parse the input with.
/// * `input` - A string containing the input to parse.
/// 
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result containing the parsed `pest::iterators::Pairs` or an `ErrorParse` if the parsing fails.
pub fn parse_by_rule(rule: Rule, input: &str) -> Result<Pairs<Rule>, ErrorParse> {
    return Grammar::parse(rule, input).map_err(|err| ErrorParse::ParsingError(err.to_string()));
}

/// Converts the markdown file at `md_path` to an HTML file at `html_path`.
/// 
/// # Arguments
/// * `md_path` - The path to the markdown file.
/// * `html_path` - The path where the generated HTML file will be saved.
///
/// # Behavior
/// - If file at `html_path` exists it overwrites content in it.
/// - If file at `html_path` does not exist, then it creates it and writes the result in it.
/// 
/// # Errors
/// - Returns an `ErrorParse::FileError` if there's an error while file r/w operation.
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result indicating success or an `ErrorParse` if a file operation fails.
pub fn md_to_html_file(md_path: &Path, html_path: &Path) -> Result<(), ErrorParse> {
    let file = File::open(md_path).map_err(ErrorParse::FileError)?;
    let reader = BufReader::new(file);

    let mut markdown_content = String::new();
    for line in reader.lines() {
        markdown_content.push_str(&line?);
        markdown_content.push('\n');
    }

    let html_lines = str_to_html(&markdown_content)?;

    let mut output_file = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(html_path)
        .map_err(ErrorParse::FileError)?;

    for line in html_lines {
        output_file
            .write_all(line.as_bytes())
            .map_err(ErrorParse::FileError)?;
        output_file
            .write_all(b"\n")
            .map_err(ErrorParse::FileError)?;
    }

    Ok(())
}

/// Converts the given markdown `text` to HTML and prints it to the console.
/// 
/// # Arguments
/// * `text` - A string containing the markdown content.
///
/// # Errors
/// - Returns an `ErrorParse::ParsingError` if there's an error during a parsing process.
/// 
/// # Returns
/// A result indicating success or an `ErrorParse` if the parsing fails.
pub fn parse_to_console(text: &str) -> Result<(), ErrorParse> {
    let res = str_to_html(text)?;

    for line in res {
        println!("{}", line);
    }

    Ok(())
}
